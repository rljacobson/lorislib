/*!

A solved equation is an abstract representation of a set of substitutions, which are said to be _generated_ by the
solved equation.

Solved sets are sets of equations, whose elements are called solved equations.  Solved equations
have one of six possible forms:

 1. x ≈ t
 2. 𝗫 ≈ g
 3. x̅ ≈ r̃
 4. x̅̅ ≈ ⸨r̃⸩
 5. x̅̅ ≈ t̃[f]
 6. x̅̅̅ ≈ ⸨t̃⸩[f]

where ⸨•⸩ denotes multisets. If eq is a solved equation, then ∑(eq) is the set of substitutions generated by eq. It
is these ∑(eq) that correspond to `MatchGenerator`s. The sets of substitutions generated by each solved equation are
summarized in the table below.

|      | Solved Equation |                     ∑(eq) = | Substitutions Generated by the Solved Equation               |
| ---- | --------------- | --------------------------: | ------------------------------------------------------------ |
| 1.   | x ≈ t           |                  ∑(x ≈ t) = | {{x ⟼ t}}                                                    |
| 2.   | 𝗫 ≈ f           |                  ∑(𝗫 ≈ f) = | {{𝗫 ⟼ f}}                                                    |
| 3.   | x̅ ≈ t̃           |                ∑( x̅ ≈ t̃ ) = | {{ x̅ ⟼ t̃ }}                                                  |
| 4.   | x̅̅ ≈ ⸨r̃⸩         |    ∑( x̅̅ ≈ ⸨t₁, t₂,…,tₙ⸩ ) = | {{x̅̅ ⟼ (tᵩ₍₁₎, tᵩ₍₂₎,…,tᵩ₍ₙ₎)} \| where 𝜑 is a permutation of (1,...,n) } |
| 5.   | x̅̅ ≈ t̃[f]        | ∑(x̅̅ ≈ (t₁, t₂,…,tₙ)[f] ) = | {{x ⟼ r̃} \| where f(t₁, t₂,…,tₙ) ≐ f( r̃ ), A(f),  r̃ is in A-normal form } |
| 6.   | x̅̅̅ ≈ ⸨t̃⸩[f]      |           ∑( x̅̅̅ ≈ ⸨t̃⸩[f] ) = | {{x ⟼ r̃} \| where f(tᵩ₍₁₎, tᵩ₍₂₎,…,tᵩ₍ₙ₎) ≐ f( r̃ ), A(f), 𝜑 is a permutation of (1,...,n),  r̃ is in AC-normal form} |


*/

use crate::{DisplayForm, ExpressionFormatter, Formattable};
use crate::interner::{InternedString, resolve_str};

// Temporary types to silence the IDE.
type Term             = InternedString;
type TermVariable     = InternedString;
type FunctionVariable = InternedString;
type Function         = InternedString;
type SequenceVariable = InternedString;
type Sequence         = InternedString;

pub enum SolvedEquation{
  // Σ(x ≈ t) = {{x ⟼ t}}
  // Matcher notation: ‹x› -> t,
  TermVariableSubstitution{lhs: TermVariable, rhs: Term},
  // ∑(𝗫 ≈ ƒ) = {{𝗫 ⟼ ƒ}}
  // Matcher notation: ‹x› -> ƒ,
  FunctionVariableSubstitution{lhs: FunctionVariable, rhs: Function},
  //  ∑( x̅ ≈ t̃ ) = {{ x̅ ⟼ t̃ }}
  //  Matcher notation: «x» -> (a, b, c)
  SequenceVariableSubstitution{lhs: SequenceVariable, rhs: Sequence},
  // Commutative Sequence Variable Substitution
  // ∑( x̅̅ ≈ ⸨t₁, t₂,…,tₙ⸩ ) = {{x̅̅ ⟼ (tᵩ₍₁₎, tᵩ₍₂₎,…,tᵩ₍ₙ₎)} | 𝜑 a permutation}
  // Matcher notation: «x» -> (a, b, c)
  CSequenceVariableSubstitution{lhs: SequenceVariable, rhs: Sequence},
  // Associative Sequence Variable Substitution
  // ∑(x̅̅ ≈ (t₁, t₂,…,tₙ)[ƒ] ) = {{x̅̅ ⟼ r̃} | ƒ(t₁, t₂,…,tₙ) ≐ ƒ( r̃ ), r̃ in A-normal form}
  // Matcher notation: «x» -> (a, b, c)
  ASequenceVariableSubstitution{lhs: SequenceVariable, rhs: Sequence},
  // Associative and Commutative Sequence Variable Substitution
  // ∑(x̅̅̅ ≈ ⸨t̃⸩[ƒ]) = {{x̅̅̅ ⟼ r̃} | ƒ(tᵩ₍₁₎,tᵩ₍₂₎,…,tᵩ₍ₙ₎) ≐ ƒ( r̃ ),
  //                     r̃ is in AC-normal form, 𝜑 a permutation}
  // Matcher notation: «x» -> (a, b, c)
  ACSequenceVariableSubstitution{lhs: SequenceVariable, rhs: Sequence},
}

impl Formattable for SolvedEquation {
  fn format(&self, formatter: &ExpressionFormatter) -> String {
    match formatter.form {
      | DisplayForm::Full //=> {/* Figure this out when we figure out the types of lhs/rhs */ }
      | DisplayForm::Input
      | DisplayForm::Standard
      | DisplayForm::Output => {
        match self {

          | SolvedEquation::TermVariableSubstitution { lhs, rhs }
          | SolvedEquation::FunctionVariableSubstitution { lhs, rhs } => {
            // We do not have a distinct function variable type. A (term) variable is a function variable if it is the
            // head of an S-expression.
            format!("{}_ -> {}", resolve_str(*lhs), resolve_str(*rhs))
          }

          | SolvedEquation::SequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::CSequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ASequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ACSequenceVariableSubstitution { lhs, rhs } => {
            // We need to distinguish between zero or more vs. one or more. Right now, there is only a one or more
            // sequence variable type.
            format!("{}___ -> {}", resolve_str(*lhs), resolve_str(*rhs))
          }

        }
      }

      DisplayForm::TeX => {
        match self {

          SolvedEquation::TermVariableSubstitution { lhs, rhs } => {
            format!("{} \\mapsto {}", resolve_str(*lhs), resolve_str(*rhs))
          }

          SolvedEquation::FunctionVariableSubstitution { lhs, rhs } => {
            // We do not have a distinct function variable type. A (term) variable is a function variable if it is the
            // head of an S-expression.
            format!("\\textbf{{{}}} \\mapsto {}", resolve_str(*lhs), resolve_str(*rhs))
          }

          | SolvedEquation::SequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::CSequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ASequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ACSequenceVariableSubstitution { lhs, rhs } => {
            // We need to distinguish between zero or more vs. one or more. Right now, there is only a one or more
            // sequence variable type.
            format!("\\overline{{{}}} \\mapsto \\widetilde{{{}}}", resolve_str(*lhs), resolve_str(*rhs))

          }

        }
      }

      | DisplayForm::Traditional
      | DisplayForm::Matcher => {
        match self {

          SolvedEquation::TermVariableSubstitution { lhs, rhs } => {
            format!("‹{}› ⟼ {}", resolve_str(*lhs), resolve_str(*rhs))
          }

          SolvedEquation::FunctionVariableSubstitution { lhs, rhs } => {
            // We do not have a distinct function variable type. A (term) variable is a function variable if it is the
            // head of an S-expression.
            format!("‹{}›❨ ❩ ⟼ {}❨ ❩", resolve_str(*lhs), resolve_str(*rhs))
          }

          | SolvedEquation::SequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::CSequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ASequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ACSequenceVariableSubstitution { lhs, rhs } => {
            // We need to distinguish between zero or more vs. one or more. Right now, there is only a one or more
            // sequence variable type.
            format!("«{}» ⟼ ({})", resolve_str(*lhs), resolve_str(*rhs))
          }

        }
      }
    }
  }
}

display_formattable_impl!(SolvedEquation);

#[cfg(test)]
mod tests {
  #[test]
  fn it_works() {
    assert_eq!(2 + 2, 4);
  }
}

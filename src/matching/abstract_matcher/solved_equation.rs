/*!

A solved equation is an abstract representation of a set of substitutions, which are said to be _generated_ by the
solved equation.

Solved sets are sets of equations, whose elements are called solved equations.  Solved equations
have one of six possible forms:

 1. x â‰ˆ t
 2. ð—« â‰ˆ g
 3. xÌ… â‰ˆ rÌƒ
 4. xÌ…Ì… â‰ˆ â¸¨rÌƒâ¸©
 5. xÌ…Ì… â‰ˆ tÌƒ[f]
 6. xÌ…Ì…Ì… â‰ˆ â¸¨tÌƒâ¸©[f]

where â¸¨â€¢â¸© denotes multisets. If eq is a solved equation, then âˆ‘(eq) is the set of substitutions generated by eq. It
is these âˆ‘(eq) that correspond to `MatchGenerator`s. The sets of substitutions generated by each solved equation are
summarized in the table below.

|      | Solved Equation |                     âˆ‘(eq) = | Substitutions Generated by the Solved Equation               |
| ---- | --------------- | --------------------------: | ------------------------------------------------------------ |
| 1.   | x â‰ˆ t           |                  âˆ‘(x â‰ˆ t) = | {{x âŸ¼ t}}                                                    |
| 2.   | ð—« â‰ˆ f           |                  âˆ‘(ð—« â‰ˆ f) = | {{ð—« âŸ¼ f}}                                                    |
| 3.   | xÌ… â‰ˆ tÌƒ           |                âˆ‘( xÌ… â‰ˆ tÌƒ ) = | {{ xÌ… âŸ¼ tÌƒ }}                                                  |
| 4.   | xÌ…Ì… â‰ˆ â¸¨rÌƒâ¸©         |    âˆ‘( xÌ…Ì… â‰ˆ â¸¨tâ‚, tâ‚‚,â€¦,tâ‚™â¸© ) = | {{xÌ…Ì… âŸ¼ (táµ©â‚â‚â‚Ž, táµ©â‚â‚‚â‚Ž,â€¦,táµ©â‚â‚™â‚Ž)} \| where ðœ‘ is a permutation of (1,...,n) } |
| 5.   | xÌ…Ì… â‰ˆ tÌƒ[f]        | âˆ‘(xÌ…Ì… â‰ˆ (tâ‚, tâ‚‚,â€¦,tâ‚™)[f] ) = | {{x âŸ¼ rÌƒ} \| where f(tâ‚, tâ‚‚,â€¦,tâ‚™) â‰ f( rÌƒ ), A(f),  rÌƒ is in A-normal form } |
| 6.   | xÌ…Ì…Ì… â‰ˆ â¸¨tÌƒâ¸©[f]      |           âˆ‘( xÌ…Ì…Ì… â‰ˆ â¸¨tÌƒâ¸©[f] ) = | {{x âŸ¼ rÌƒ} \| where f(táµ©â‚â‚â‚Ž, táµ©â‚â‚‚â‚Ž,â€¦,táµ©â‚â‚™â‚Ž) â‰ f( rÌƒ ), A(f), ðœ‘ is a permutation of (1,...,n),  rÌƒ is in AC-normal form} |


*/

use crate::{DisplayForm, ExpressionFormatter, Formattable};
use crate::interner::{InternedString, resolve_str};

// Temporary types to silence the IDE.
type Term             = InternedString;
type TermVariable     = InternedString;
type FunctionVariable = InternedString;
type Function         = InternedString;
type SequenceVariable = InternedString;
type Sequence         = InternedString;

pub enum SolvedEquation{
  // Î£(x â‰ˆ t) = {{x âŸ¼ t}}
  // Matcher notation: â€¹xâ€º -> t,
  TermVariableSubstitution{lhs: TermVariable, rhs: Term},
  // âˆ‘(ð—« â‰ˆ Æ’) = {{ð—« âŸ¼ Æ’}}
  // Matcher notation: â€¹xâ€º -> Æ’,
  FunctionVariableSubstitution{lhs: FunctionVariable, rhs: Function},
  //  âˆ‘( xÌ… â‰ˆ tÌƒ ) = {{ xÌ… âŸ¼ tÌƒ }}
  //  Matcher notation: Â«xÂ» -> (a, b, c)
  SequenceVariableSubstitution{lhs: SequenceVariable, rhs: Sequence},
  // Commutative Sequence Variable Substitution
  // âˆ‘( xÌ…Ì… â‰ˆ â¸¨tâ‚, tâ‚‚,â€¦,tâ‚™â¸© ) = {{xÌ…Ì… âŸ¼ (táµ©â‚â‚â‚Ž, táµ©â‚â‚‚â‚Ž,â€¦,táµ©â‚â‚™â‚Ž)} | ðœ‘ a permutation}
  // Matcher notation: Â«xÂ» -> (a, b, c)
  CSequenceVariableSubstitution{lhs: SequenceVariable, rhs: Sequence},
  // Associative Sequence Variable Substitution
  // âˆ‘(xÌ…Ì… â‰ˆ (tâ‚, tâ‚‚,â€¦,tâ‚™)[Æ’] ) = {{xÌ…Ì… âŸ¼ rÌƒ} | Æ’(tâ‚, tâ‚‚,â€¦,tâ‚™) â‰ Æ’( rÌƒ ), rÌƒ in A-normal form}
  // Matcher notation: Â«xÂ» -> (a, b, c)
  ASequenceVariableSubstitution{lhs: SequenceVariable, rhs: Sequence},
  // Associative and Commutative Sequence Variable Substitution
  // âˆ‘(xÌ…Ì…Ì… â‰ˆ â¸¨tÌƒâ¸©[Æ’]) = {{xÌ…Ì…Ì… âŸ¼ rÌƒ} | Æ’(táµ©â‚â‚â‚Ž,táµ©â‚â‚‚â‚Ž,â€¦,táµ©â‚â‚™â‚Ž) â‰ Æ’( rÌƒ ),
  //                     rÌƒ is in AC-normal form, ðœ‘ a permutation}
  // Matcher notation: Â«xÂ» -> (a, b, c)
  ACSequenceVariableSubstitution{lhs: SequenceVariable, rhs: Sequence},
}

impl Formattable for SolvedEquation {
  fn format(&self, formatter: &ExpressionFormatter) -> String {
    match formatter.form {
      | DisplayForm::Full //=> {/* Figure this out when we figure out the types of lhs/rhs */ }
      | DisplayForm::Input
      | DisplayForm::Standard
      | DisplayForm::Output => {
        match self {

          | SolvedEquation::TermVariableSubstitution { lhs, rhs }
          | SolvedEquation::FunctionVariableSubstitution { lhs, rhs } => {
            // We do not have a distinct function variable type. A (term) variable is a function variable if it is the
            // head of an S-expression.
            format!("{}_ -> {}", resolve_str(*lhs), resolve_str(*rhs))
          }

          | SolvedEquation::SequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::CSequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ASequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ACSequenceVariableSubstitution { lhs, rhs } => {
            // We need to distinguish between zero or more vs. one or more. Right now, there is only a one or more
            // sequence variable type.
            format!("{}___ -> {}", resolve_str(*lhs), resolve_str(*rhs))
          }

        }
      }

      DisplayForm::TeX => {
        match self {

          SolvedEquation::TermVariableSubstitution { lhs, rhs } => {
            format!("{} \\mapsto {}", resolve_str(*lhs), resolve_str(*rhs))
          }

          SolvedEquation::FunctionVariableSubstitution { lhs, rhs } => {
            // We do not have a distinct function variable type. A (term) variable is a function variable if it is the
            // head of an S-expression.
            format!("\\textbf{{{}}} \\mapsto {}", resolve_str(*lhs), resolve_str(*rhs))
          }

          | SolvedEquation::SequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::CSequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ASequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ACSequenceVariableSubstitution { lhs, rhs } => {
            // We need to distinguish between zero or more vs. one or more. Right now, there is only a one or more
            // sequence variable type.
            format!("\\overline{{{}}} \\mapsto \\widetilde{{{}}}", resolve_str(*lhs), resolve_str(*rhs))

          }

        }
      }

      | DisplayForm::Traditional
      | DisplayForm::Matcher => {
        match self {

          SolvedEquation::TermVariableSubstitution { lhs, rhs } => {
            format!("â€¹{}â€º âŸ¼ {}", resolve_str(*lhs), resolve_str(*rhs))
          }

          SolvedEquation::FunctionVariableSubstitution { lhs, rhs } => {
            // We do not have a distinct function variable type. A (term) variable is a function variable if it is the
            // head of an S-expression.
            format!("â€¹{}â€ºâ¨ â© âŸ¼ {}â¨ â©", resolve_str(*lhs), resolve_str(*rhs))
          }

          | SolvedEquation::SequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::CSequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ASequenceVariableSubstitution { lhs, rhs }
          | SolvedEquation::ACSequenceVariableSubstitution { lhs, rhs } => {
            // We need to distinguish between zero or more vs. one or more. Right now, there is only a one or more
            // sequence variable type.
            format!("Â«{}Â» âŸ¼ ({})", resolve_str(*lhs), resolve_str(*rhs))
          }

        }
      }
    }
  }
}

display_formattable_impl!(SolvedEquation);

#[cfg(test)]
mod tests {
  #[test]
  fn it_works() {
    assert_eq!(2 + 2, 4);
  }
}
